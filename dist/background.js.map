{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://kavach-trial/./src/utils/privacy.ts","webpack://kavach-trial/webpack/bootstrap","webpack://kavach-trial/webpack/runtime/define property getters","webpack://kavach-trial/webpack/runtime/hasOwnProperty shorthand","webpack://kavach-trial/webpack/runtime/make namespace object","webpack://kavach-trial/./src/background/index.ts"],"sourcesContent":["export class TrustScoreCalculator {\n    static calculateScore(trackers, privacyRisks = []) {\n        let score = 100;\n        // Deduct points for trackers\n        const trackerPenalty = Math.min(trackers.length * 5, 40);\n        score -= trackerPenalty;\n        // Deduct points for high-risk trackers\n        const highRiskTrackers = trackers.filter(t => ['advertising', 'social', 'analytics'].includes(t.category));\n        score -= highRiskTrackers.length * 3;\n        // Deduct points for privacy policy risks\n        score -= Math.min(privacyRisks.length * 8, 30);\n        return Math.max(0, Math.min(100, score));\n    }\n}\nexport class PrivacyPolicyAnalyzer {\n    static async analyzePolicy(url) {\n        // Simulate AI analysis - in real implementation, this would call an AI service\n        const mockAnalysis = {\n            score: Math.floor(Math.random() * 40) + 60,\n            risks: [\n                'Data may be shared with third parties',\n                'Vague data retention policies',\n                'No explicit user consent for cookies'\n            ],\n            summary: 'This policy contains some concerning clauses about data sharing and lacks clarity on user rights.',\n            dataSharing: ['Facebook', 'Google Analytics', 'Oracle']\n        };\n        return mockAnalysis;\n    }\n}\nexport const commonTrackers = {\n    'doubleclick.net': { category: 'advertising', name: 'Google DoubleClick' },\n    'googletagmanager.com': { category: 'analytics', name: 'Google Tag Manager' },\n    'facebook.com': { category: 'social', name: 'Facebook Pixel' },\n    'google-analytics.com': { category: 'analytics', name: 'Google Analytics' },\n    'connect.facebook.net': { category: 'social', name: 'Facebook Connect' },\n    'amazon-adsystem.com': { category: 'advertising', name: 'Amazon Advertising' },\n    'twitter.com': { category: 'social', name: 'Twitter Analytics' },\n    'linkedin.com': { category: 'social', name: 'LinkedIn Insights' }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { TrustScoreCalculator, commonTrackers } from '../utils/privacy';\nclass BackgroundService {\n    constructor() {\n        this.siteData = new Map();\n        this.blockedRequests = new Map();\n        this.privacyPolicyUrls = new Map();\n        console.log('🚀 Kavach Background Service starting...');\n        this.setupRequestBlocking();\n        this.setupTabListeners();\n        this.setupMessageListeners();\n        console.log('✅ Kavach Background Service initialized');\n    }\n    safeParseURL(url) {\n        try {\n            if (!url || typeof url !== 'string') {\n                console.warn('❌ Invalid URL input:', url);\n                return null;\n            }\n            return new URL(url);\n        }\n        catch (error) {\n            console.warn('❌ Failed to parse URL:', url, error);\n            return null;\n        }\n    }\n    getDomainFromURL(url) {\n        const parsedUrl = this.safeParseURL(url);\n        return parsedUrl ? parsedUrl.hostname : null;\n    }\n    setupRequestBlocking() {\n        console.log('🛡️ Kavach: Setting up request blocking...');\n        // Monitor web requests to track third-party requests\n        chrome.webRequest.onBeforeRequest.addListener((details) => {\n            console.log('🌐 Request detected:', details.url, 'Type:', details.type, 'Initiator:', details.initiator);\n            if (details.type === 'main_frame')\n                return {};\n            const url = this.safeParseURL(details.url);\n            const initiatorUrl = details.initiator ? this.safeParseURL(details.initiator) : null;\n            if (url && initiatorUrl && url.hostname !== initiatorUrl.hostname) {\n                console.log('🚨 Third-party request:', url.hostname, 'from', initiatorUrl.hostname);\n                this.trackThirdPartyRequest(initiatorUrl.hostname, url.hostname, details.type);\n            }\n            return {};\n        }, { urls: ['<all_urls>'] }, ['requestBody']);\n    }\n    setupTabListeners() {\n        console.log('👂 Setting up tab listeners...');\n        chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n            if (changeInfo.status === 'complete' && tab.url && this.isValidHttpUrl(tab.url)) {\n                console.log('📄 Tab completed loading:', tab.url);\n                this.initializeSiteData(tab.url);\n            }\n        });\n        // Also listen for tab activation to ensure we have data for active tabs\n        chrome.tabs.onActivated.addListener(async (activeInfo) => {\n            try {\n                const tab = await chrome.tabs.get(activeInfo.tabId);\n                if (tab.url && this.isValidHttpUrl(tab.url)) {\n                    console.log('🔄 Tab activated:', tab.url);\n                    this.initializeSiteData(tab.url);\n                }\n            }\n            catch (error) {\n                console.log('❌ Error getting active tab:', error);\n            }\n        });\n    }\n    isValidHttpUrl(url) {\n        try {\n            const parsedUrl = new URL(url);\n            return parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:';\n        }\n        catch {\n            return false;\n        }\n    }\n    trackThirdPartyRequest(sourceDomain, trackerDomain, requestType) {\n        console.log('📊 Tracking third-party request:', { sourceDomain, trackerDomain, requestType });\n        let siteData = this.siteData.get(sourceDomain);\n        if (!siteData) {\n            console.log('❌ No site data found for:', sourceDomain, '- Creating new site data');\n            // Initialize site data for this domain\n            this.initializeSiteDataForDomain(sourceDomain);\n            siteData = this.siteData.get(sourceDomain);\n            if (!siteData) {\n                console.log('❌ Failed to create site data for:', sourceDomain);\n                return;\n            }\n        }\n        const existingTracker = siteData.trackers.find(t => t.domain === trackerDomain);\n        if (existingTracker) {\n            existingTracker.count++;\n            console.log('📈 Updated tracker count:', trackerDomain, existingTracker.count);\n        }\n        else {\n            const trackerInfo = commonTrackers[trackerDomain];\n            const newTracker = {\n                domain: trackerDomain,\n                count: 1,\n                category: trackerInfo?.category || 'unknown',\n                blocked: this.isTrackerBlocked(trackerDomain)\n            };\n            siteData.trackers.push(newTracker);\n            console.log('🆕 New tracker detected:', newTracker);\n        }\n        // Recalculate trust score\n        const oldScore = siteData.trustScore;\n        siteData.trustScore = TrustScoreCalculator.calculateScore(siteData.trackers);\n        console.log('🎯 Trust score updated:', oldScore, '→', siteData.trustScore);\n        // Update data flow visualization\n        this.updateDataFlow(siteData, sourceDomain, trackerDomain);\n        this.siteData.set(sourceDomain, siteData);\n    }\n    isTrackerBlocked(domain) {\n        // Check if domain is in our blocking rules\n        const blockedDomains = ['doubleclick.net', 'googletagmanager.com', 'facebook.com/tr'];\n        return blockedDomains.some(blocked => domain.includes(blocked));\n    }\n    updateDataFlow(siteData, source, tracker) {\n        // Add nodes if they don't exist\n        if (!siteData.dataFlow.nodes.find(n => n.id === source)) {\n            siteData.dataFlow.nodes.push({\n                id: source,\n                domain: source,\n                type: 'source',\n                position: { x: 100, y: 100 }\n            });\n        }\n        if (!siteData.dataFlow.nodes.find(n => n.id === tracker)) {\n            const nodeCount = siteData.dataFlow.nodes.length;\n            siteData.dataFlow.nodes.push({\n                id: tracker,\n                domain: tracker,\n                type: 'tracker',\n                position: { x: 200 + (nodeCount * 100), y: 150 }\n            });\n        }\n        // Add edge if it doesn't exist\n        if (!siteData.dataFlow.edges.find(e => e.from === source && e.to === tracker)) {\n            siteData.dataFlow.edges.push({\n                from: source,\n                to: tracker,\n                dataType: 'user_data'\n            });\n        }\n    }\n    initializeSiteData(url) {\n        const domain = this.getDomainFromURL(url);\n        if (!domain) {\n            console.warn('❌ Cannot initialize site data for invalid URL:', url);\n            return;\n        }\n        console.log('🏠 Initializing site data for:', domain);\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url,\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n            console.log('✅ Site data initialized:', newSiteData);\n        }\n        else {\n            console.log('♻️ Site data already exists for:', domain);\n        }\n    }\n    initializeSiteDataForDomain(domain) {\n        console.log('🏠 Initializing site data for domain:', domain);\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url: `https://${domain}`, // Construct basic URL from domain\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n            console.log('✅ Site data initialized for domain:', newSiteData);\n        }\n        else {\n            console.log('♻️ Site data already exists for domain:', domain);\n        }\n    }\n    async getSiteData(url) {\n        const domain = this.getDomainFromURL(url);\n        if (!domain) {\n            console.warn('❌ Cannot get site data for invalid URL:', url);\n            return null;\n        }\n        // Ensure site data exists for this domain\n        if (!this.siteData.has(domain)) {\n            console.log('🔄 Site data not found, initializing for:', domain);\n            this.initializeSiteData(url);\n        }\n        const siteData = this.siteData.get(domain) || null;\n        console.log('📊 Getting site data for:', domain, 'Found:', !!siteData, 'Trackers:', siteData?.trackers?.length || 0);\n        return siteData;\n    }\n    async toggleTrackerBlocking(enabled) {\n        // Toggle declarative net request rules\n        const ruleIds = [1, 2, 3, 4, 5]; // IDs from rules.json\n        if (enabled) {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                enableRulesetIds: ['tracker_rules']\n            });\n        }\n        else {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                disableRulesetIds: ['tracker_rules']\n            });\n        }\n    }\n    setupMessageListeners() {\n        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n            console.log('📨 Message received:', request.action, request);\n            switch (request.action) {\n                case 'getSiteData':\n                    this.getSiteData(request.url).then(sendResponse);\n                    return true;\n                case 'getFingerprintScript':\n                    this.getFingerprintScript(request.apiKey).then(sendResponse);\n                    return true;\n                case 'toggleBlocking':\n                    this.toggleTrackerBlocking(request.enabled).then(() => {\n                        sendResponse({ success: true });\n                    });\n                    return true;\n                case 'analyzePrivacyPolicy':\n                    this.analyzePrivacyPolicy(request.url).then(sendResponse);\n                    return true;\n                case 'privacyPoliciesFound':\n                    this.storePrivacyPolicyUrls(request.currentUrl, request.urls);\n                    sendResponse({ success: true });\n                    return true;\n                case 'debugInfo':\n                    // Return debug information\n                    const debugInfo = {\n                        trackedDomains: Array.from(this.siteData.keys()),\n                        totalSites: this.siteData.size,\n                        siteDataSnapshot: Array.from(this.siteData.entries()).map(([domain, data]) => ({\n                            domain,\n                            trackerCount: data.trackers.length,\n                            trustScore: data.trustScore\n                        }))\n                    };\n                    console.log('🐛 Debug info requested:', debugInfo);\n                    sendResponse(debugInfo);\n                    return true;\n                case 'runFingerprint':\n                    if (request.tabId) {\n                        this.handleFingerprinting(request.apiKey, request.tabId)\n                            .then(sendResponse)\n                            .catch(error => sendResponse({ success: false, error: error.message }));\n                    }\n                    else {\n                        sendResponse({ success: false, error: 'No tabId provided in the request.' });\n                    }\n                    return true; // Keep channel open for async response\n            }\n        });\n    }\n    storePrivacyPolicyUrls(siteUrl, policyUrls) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (!domain) {\n            console.warn('❌ Cannot store privacy policy URLs for invalid URL:', siteUrl);\n            return;\n        }\n        this.privacyPolicyUrls.set(domain, policyUrls);\n    }\n    async analyzePrivacyPolicy(siteUrl) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (!domain) {\n            console.warn('❌ Cannot analyze privacy policy for invalid URL:', siteUrl);\n            return { error: 'Invalid URL provided' };\n        }\n        const policyUrls = this.privacyPolicyUrls.get(domain) || [];\n        // If no privacy policy URLs found, try to find them with enhanced detection\n        if (policyUrls.length === 0) {\n            // Expanded list of common privacy policy paths\n            const commonPaths = [\n                '/privacy',\n                '/privacy-policy',\n                '/privacy.html',\n                '/privacy.php',\n                '/privacy.aspx',\n                '/terms',\n                '/terms-of-service',\n                '/terms-and-conditions',\n                '/legal/privacy',\n                '/legal/terms',\n                '/help/privacy',\n                '/support/privacy',\n                '/about/privacy',\n                '/policies/privacy',\n                '/privacy-statement',\n                '/privacy-notice',\n                '/data-protection',\n                '/cookie-policy',\n                '/gdpr',\n                '/ccpa'\n            ];\n            // Try multiple variations with different protocols and subdomains\n            const urlVariations = [\n                `https://${domain}`,\n                `https://www.${domain}`,\n                `http://${domain}`,\n                `http://www.${domain}`\n            ];\n            for (const baseUrl of urlVariations) {\n                for (const path of commonPaths) {\n                    try {\n                        // Use AbortController for timeout\n                        const controller = new AbortController();\n                        const timeoutId = setTimeout(() => controller.abort(), 5000);\n                        const response = await fetch(`${baseUrl}${path}`, {\n                            method: 'HEAD', // Use HEAD request for faster checking\n                            signal: controller.signal\n                        });\n                        clearTimeout(timeoutId);\n                        if (response.ok) {\n                            policyUrls.push(`${baseUrl}${path}`);\n                            break; // Found one, move to next base URL\n                        }\n                    }\n                    catch (e) {\n                        // Continue to next path\n                    }\n                }\n                if (policyUrls.length > 0)\n                    break; // Found policy, stop searching\n            }\n        }\n        if (policyUrls.length === 0) {\n            return {\n                score: 50,\n                risks: ['No privacy policy found'],\n                summary: 'Unable to locate a privacy policy for this website.',\n                dataSharing: []\n            };\n        }\n        // Fetch and analyze the privacy policy\n        try {\n            const policyText = await this.fetchPrivacyPolicyText(policyUrls[0]);\n            const analysis = await this.performPrivacyAnalysis(policyText, domain);\n            // Store the analysis in site data\n            const siteData = this.siteData.get(domain);\n            if (siteData) {\n                siteData.privacyAnalysis = analysis;\n                this.siteData.set(domain, siteData);\n            }\n            return analysis;\n        }\n        catch (error) {\n            console.error('Privacy policy analysis failed:', error);\n            return {\n                score: 30,\n                risks: ['Failed to analyze privacy policy'],\n                summary: 'Privacy policy analysis failed due to technical issues.',\n                dataSharing: []\n            };\n        }\n    }\n    async fetchPrivacyPolicyText(policyUrl) {\n        try {\n            const response = await fetch(policyUrl);\n            const html = await response.text();\n            // Remove script and style tags\n            let cleanHtml = html.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n            cleanHtml = cleanHtml.replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '');\n            // Remove all HTML tags and decode entities\n            let textContent = cleanHtml.replace(/<[^>]*>/g, ' ');\n            // Decode common HTML entities\n            textContent = textContent.replace(/&nbsp;/g, ' ')\n                .replace(/&amp;/g, '&')\n                .replace(/&lt;/g, '<')\n                .replace(/&gt;/g, '>')\n                .replace(/&quot;/g, '\"')\n                .replace(/&#39;/g, \"'\");\n            // Clean up whitespace\n            textContent = textContent.replace(/\\s+/g, ' ').trim();\n            return textContent;\n        }\n        catch (error) {\n            console.error('Failed to fetch privacy policy:', policyUrl, error);\n            throw new Error(`Failed to fetch privacy policy: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    async performPrivacyAnalysis(policyText, domain) {\n        const text = policyText.toLowerCase();\n        const risks = [];\n        const dataSharing = [];\n        let score = 80; // Start with a higher base score\n        // Enhanced risk detection with more sophisticated patterns\n        const riskPatterns = {\n            'Data Selling': {\n                keywords: ['sell', 'sale', 'sold', 'monetize', 'revenue from data', 'third-party purchasers'],\n                penalty: 25,\n                context: ['personal information', 'user data', 'your data']\n            },\n            'Cross-site Tracking': {\n                keywords: ['track across', 'follow you', 'behavioral tracking', 'cross-site', 'cross-platform'],\n                penalty: 20,\n                context: ['websites', 'platforms', 'services']\n            },\n            'Vague Data Retention': {\n                keywords: ['indefinitely', 'as long as necessary', 'business purposes', 'legal requirements'],\n                penalty: 15,\n                context: ['retain', 'keep', 'store', 'maintain']\n            },\n            'Limited User Control': {\n                keywords: ['cannot delete', 'unable to remove', 'permanent', 'irrevocable'],\n                penalty: 20,\n                context: ['account', 'data', 'information']\n            },\n            'Broad Data Collection': {\n                keywords: ['all information', 'any data', 'everything', 'comprehensive'],\n                penalty: 15,\n                context: ['collect', 'gather', 'obtain']\n            },\n            'Weak Consent Mechanisms': {\n                keywords: ['deemed consent', 'implied consent', 'continued use', 'by using'],\n                penalty: 18,\n                context: ['agree', 'consent', 'acceptance']\n            },\n            'Data Sharing with Law Enforcement': {\n                keywords: ['law enforcement', 'government agencies', 'legal process', 'subpoena'],\n                penalty: 10,\n                context: ['share', 'provide', 'disclose']\n            },\n            'Location Tracking': {\n                keywords: ['precise location', 'gps', 'geolocation', 'whereabouts'],\n                penalty: 15,\n                context: ['track', 'collect', 'monitor']\n            },\n            'Biometric Data Collection': {\n                keywords: ['biometric', 'fingerprint', 'facial recognition', 'voice print'],\n                penalty: 20,\n                context: ['collect', 'process', 'store']\n            },\n            'Children Data Collection': {\n                keywords: ['under 13', 'children', 'minors', 'parental consent'],\n                penalty: 25,\n                context: ['collect', 'process', 'target']\n            }\n        };\n        // Check for risks with context awareness\n        for (const [riskName, config] of Object.entries(riskPatterns)) {\n            const hasKeywords = config.keywords.some(keyword => text.includes(keyword));\n            const hasContext = config.context.some(context => text.includes(context));\n            if (hasKeywords && hasContext) {\n                risks.push(riskName);\n                score -= config.penalty;\n            }\n        }\n        // Enhanced data sharing detection\n        const sharingEntities = {\n            'Google': ['google', 'alphabet', 'youtube', 'gmail', 'google analytics', 'doubleclick'],\n            'Meta/Facebook': ['facebook', 'meta', 'instagram', 'whatsapp', 'messenger'],\n            'Amazon': ['amazon', 'aws', 'amazon web services', 'alexa'],\n            'Microsoft': ['microsoft', 'office 365', 'azure', 'bing'],\n            'Apple': ['apple', 'icloud', 'itunes', 'app store'],\n            'TikTok/ByteDance': ['tiktok', 'bytedance'],\n            'Twitter/X': ['twitter', 'x corp'],\n            'Advertising Networks': ['adsense', 'admob', 'advertising partners', 'ad networks'],\n            'Analytics Providers': ['analytics', 'tracking', 'measurement', 'statistics'],\n            'Data Brokers': ['data broker', 'information broker', 'third-party data'],\n            'Marketing Partners': ['marketing partners', 'promotional partners', 'affiliates'],\n            'Government Agencies': ['government', 'law enforcement', 'regulatory agencies']\n        };\n        for (const [entity, keywords] of Object.entries(sharingEntities)) {\n            const mentioned = keywords.some(keyword => text.includes(keyword));\n            if (mentioned && !dataSharing.includes(entity)) {\n                dataSharing.push(entity);\n            }\n        }\n        // Positive privacy practices (score bonuses)\n        const positivePatterns = [\n            { keywords: ['opt-out', 'opt out'], bonus: 8, description: 'Clear opt-out mechanisms' },\n            { keywords: ['delete account', 'data deletion'], bonus: 10, description: 'Account deletion available' },\n            { keywords: ['anonymize', 'anonymization'], bonus: 6, description: 'Data anonymization' },\n            { keywords: ['encryption', 'encrypted'], bonus: 8, description: 'Data encryption' },\n            { keywords: ['minimal data', 'data minimization'], bonus: 12, description: 'Data minimization principle' },\n            { keywords: ['user control', 'user choice'], bonus: 8, description: 'User control emphasized' },\n            { keywords: ['transparent', 'transparency'], bonus: 6, description: 'Transparency commitment' },\n            { keywords: ['third-party audits', 'security audits'], bonus: 10, description: 'Security auditing' },\n            { keywords: ['gdpr', 'ccpa', 'privacy rights'], bonus: 12, description: 'Privacy law compliance' }\n        ];\n        const positiveFeatures = [];\n        for (const pattern of positivePatterns) {\n            const hasPositive = pattern.keywords.some(keyword => text.includes(keyword));\n            if (hasPositive) {\n                score += pattern.bonus;\n                positiveFeatures.push(pattern.description);\n            }\n        }\n        // Industry-specific risk assessment\n        const industryRisks = {\n            'Social Media': ['social', 'posts', 'friends', 'connections'],\n            'E-commerce': ['purchase', 'shopping', 'payment', 'transactions'],\n            'Financial': ['financial', 'banking', 'credit', 'loan'],\n            'Healthcare': ['health', 'medical', 'patient', 'treatment'],\n            'Education': ['student', 'academic', 'education', 'learning']\n        };\n        let industryType = 'General';\n        for (const [industry, keywords] of Object.entries(industryRisks)) {\n            const isIndustry = keywords.some(keyword => text.includes(keyword));\n            if (isIndustry) {\n                industryType = industry;\n                // Apply industry-specific scoring adjustments\n                if (industry === 'Financial' || industry === 'Healthcare') {\n                    score -= 5; // Higher standards for sensitive industries\n                }\n                break;\n            }\n        }\n        // Ensure score stays within bounds\n        score = Math.max(0, Math.min(100, score));\n        // Generate enhanced summary\n        let summary = `This ${industryType.toLowerCase()} privacy policy has been analyzed for comprehensive privacy practices. `;\n        if (score >= 80) {\n            summary += 'The policy demonstrates strong privacy protection with clear user rights, limited data sharing, and transparent practices.';\n        }\n        else if (score >= 60) {\n            summary += 'The policy shows reasonable privacy practices but has some areas of concern regarding data collection or sharing.';\n        }\n        else if (score >= 40) {\n            summary += 'The policy has significant privacy concerns with extensive data collection, sharing, or unclear user rights.';\n        }\n        else {\n            summary += 'The policy raises serious privacy concerns with poor user protection, extensive data sharing, or lack of user control.';\n        }\n        if (positiveFeatures.length > 0) {\n            summary += ` Positive aspects include: ${positiveFeatures.slice(0, 3).join(', ')}.`;\n        }\n        return {\n            score,\n            risks: risks.slice(0, 8), // Limit to most important risks\n            summary,\n            dataSharing: [...new Set(dataSharing)].slice(0, 8), // Remove duplicates and limit\n            industryType,\n            positiveFeatures: positiveFeatures.slice(0, 5),\n            analysisDepth: 'Enhanced AI Analysis',\n            lastAnalyzed: new Date().toISOString()\n        };\n    }\n    async getFingerprintScript(apiKey) {\n        const loaderUrl = `https://fpnpmcdn.net/v3/${apiKey}/loader_v3.11.10.js`;\n        try {\n            const response = await fetch(loaderUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch script: ${response.statusText}`);\n            }\n            const script = await response.text();\n            return { script };\n        }\n        catch (error) {\n            console.error('Failed to fetch FingerprintJS script:', error);\n            return { error: error.message };\n        }\n    }\n    async handleFingerprinting(apiKey, tabId) {\n        try {\n            // Inject the bundled fingerprinting script into the active tab's main world\n            await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                files: ['fingerprint-agent.js'],\n                world: 'MAIN'\n            });\n            // Now execute the code to run FingerprintJS in the main world\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                func: runFingerprintJS,\n                args: [apiKey],\n                world: 'MAIN'\n            });\n            if (results && results[0] && results[0].result) {\n                return results[0].result;\n            }\n            else {\n                throw new Error('No result returned from fingerprinting script');\n            }\n        }\n        catch (error) {\n            console.error('Background fingerprinting error:', error);\n            return {\n                success: false,\n                error: `Failed to run fingerprinting: ${error.message}`\n            };\n        }\n    }\n}\n// This function gets injected into the webpage after the agent is injected\nfunction runFingerprintJS(apiKey) {\n    return new Promise((resolve) => {\n        // The FingerprintJS object is now available on the window\n        // thanks to the injected fingerprint-agent.js script.\n        async function initializeFingerprint() {\n            try {\n                const fp = await window.FingerprintJS.load({\n                    apiKey: apiKey,\n                    region: 'ap'\n                });\n                const result = await fp.get({\n                    extendedResult: true\n                });\n                resolve({\n                    success: true,\n                    data: {\n                        visitorId: result.visitorId,\n                        confidence: result.confidence,\n                        components: result.components,\n                        requestId: result.requestId,\n                        timestamp: Date.now()\n                    }\n                });\n            }\n            catch (error) {\n                resolve({\n                    success: false,\n                    error: `Fingerprinting failed: ${error.message}`\n                });\n            }\n        }\n        // Wait for the FingerprintJS object to be available\n        let checks = 0;\n        const interval = setInterval(() => {\n            checks++;\n            if (window.FingerprintJS) {\n                clearInterval(interval);\n                initializeFingerprint();\n            }\n            else if (checks > 50) { // Timeout after 5 seconds\n                clearInterval(interval);\n                resolve({ success: false, error: 'FingerprintJS object not found after script injection.' });\n            }\n        }, 100);\n    });\n}\nconst backgroundService = new BackgroundService();\n"],"names":[],"sourceRoot":""}