{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://kavach-trial/./src/utils/privacy.ts","webpack://kavach-trial/webpack/bootstrap","webpack://kavach-trial/webpack/runtime/define property getters","webpack://kavach-trial/webpack/runtime/hasOwnProperty shorthand","webpack://kavach-trial/webpack/runtime/make namespace object","webpack://kavach-trial/./src/background/index.ts"],"sourcesContent":["export class TrustScoreCalculator {\n    static calculateScore(trackers, privacyRisks = []) {\n        let score = 100;\n        // Deduct points for trackers\n        const trackerPenalty = Math.min(trackers.length * 5, 40);\n        score -= trackerPenalty;\n        // Deduct points for high-risk trackers\n        const highRiskTrackers = trackers.filter(t => ['advertising', 'social', 'analytics'].includes(t.category));\n        score -= highRiskTrackers.length * 3;\n        // Deduct points for privacy policy risks\n        score -= Math.min(privacyRisks.length * 8, 30);\n        return Math.max(0, Math.min(100, score));\n    }\n}\nexport class PrivacyPolicyAnalyzer {\n    static async analyzePolicy(url) {\n        // Simulate AI analysis - in real implementation, this would call an AI service\n        const mockAnalysis = {\n            score: Math.floor(Math.random() * 40) + 60,\n            risks: [\n                'Data may be shared with third parties',\n                'Vague data retention policies',\n                'No explicit user consent for cookies'\n            ],\n            summary: 'This policy contains some concerning clauses about data sharing and lacks clarity on user rights.',\n            dataSharing: ['Facebook', 'Google Analytics', 'Oracle']\n        };\n        return mockAnalysis;\n    }\n}\nexport const commonTrackers = {\n    'doubleclick.net': { category: 'advertising', name: 'Google DoubleClick' },\n    'googletagmanager.com': { category: 'analytics', name: 'Google Tag Manager' },\n    'facebook.com': { category: 'social', name: 'Facebook Pixel' },\n    'google-analytics.com': { category: 'analytics', name: 'Google Analytics' },\n    'connect.facebook.net': { category: 'social', name: 'Facebook Connect' },\n    'amazon-adsystem.com': { category: 'advertising', name: 'Amazon Advertising' },\n    'twitter.com': { category: 'social', name: 'Twitter Analytics' },\n    'linkedin.com': { category: 'social', name: 'LinkedIn Insights' }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { TrustScoreCalculator, commonTrackers } from '../utils/privacy';\nclass BackgroundService {\n    constructor() {\n        this.siteData = new Map();\n        this.blockedRequests = new Map();\n        this.privacyPolicyUrls = new Map();\n        console.log('🚀 Kavach Background Service starting...');\n        this.setupRequestBlocking();\n        this.setupTabListeners();\n        this.setupMessageListeners();\n        console.log('✅ Kavach Background Service initialized');\n    }\n    setupRequestBlocking() {\n        console.log('🛡️ Kavach: Setting up request blocking...');\n        // Monitor web requests to track third-party requests\n        chrome.webRequest.onBeforeRequest.addListener((details) => {\n            console.log('🌐 Request detected:', details.url, 'Type:', details.type, 'Initiator:', details.initiator);\n            if (details.type === 'main_frame')\n                return {};\n            const url = new URL(details.url);\n            const initiatorUrl = details.initiator ? new URL(details.initiator) : null;\n            if (initiatorUrl && url.hostname !== initiatorUrl.hostname) {\n                console.log('🚨 Third-party request:', url.hostname, 'from', initiatorUrl.hostname);\n                this.trackThirdPartyRequest(initiatorUrl.hostname, url.hostname, details.type);\n            }\n            return {};\n        }, { urls: ['<all_urls>'] }, ['requestBody']);\n    }\n    setupTabListeners() {\n        console.log('👂 Setting up tab listeners...');\n        chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n            if (changeInfo.status === 'complete' && tab.url) {\n                console.log('📄 Tab completed loading:', tab.url);\n                this.initializeSiteData(tab.url);\n            }\n        });\n        // Also listen for tab activation to ensure we have data for active tabs\n        chrome.tabs.onActivated.addListener(async (activeInfo) => {\n            try {\n                const tab = await chrome.tabs.get(activeInfo.tabId);\n                if (tab.url) {\n                    console.log('🔄 Tab activated:', tab.url);\n                    this.initializeSiteData(tab.url);\n                }\n            }\n            catch (error) {\n                console.log('❌ Error getting active tab:', error);\n            }\n        });\n    }\n    trackThirdPartyRequest(sourceDomain, trackerDomain, requestType) {\n        console.log('📊 Tracking third-party request:', { sourceDomain, trackerDomain, requestType });\n        let siteData = this.siteData.get(sourceDomain);\n        if (!siteData) {\n            console.log('❌ No site data found for:', sourceDomain, '- Creating new site data');\n            // Initialize site data for this domain\n            this.initializeSiteDataForDomain(sourceDomain);\n            siteData = this.siteData.get(sourceDomain);\n            if (!siteData) {\n                console.log('❌ Failed to create site data for:', sourceDomain);\n                return;\n            }\n        }\n        const existingTracker = siteData.trackers.find(t => t.domain === trackerDomain);\n        if (existingTracker) {\n            existingTracker.count++;\n            console.log('📈 Updated tracker count:', trackerDomain, existingTracker.count);\n        }\n        else {\n            const trackerInfo = commonTrackers[trackerDomain];\n            const newTracker = {\n                domain: trackerDomain,\n                count: 1,\n                category: trackerInfo?.category || 'unknown',\n                blocked: this.isTrackerBlocked(trackerDomain)\n            };\n            siteData.trackers.push(newTracker);\n            console.log('🆕 New tracker detected:', newTracker);\n        }\n        // Recalculate trust score\n        const oldScore = siteData.trustScore;\n        siteData.trustScore = TrustScoreCalculator.calculateScore(siteData.trackers);\n        console.log('🎯 Trust score updated:', oldScore, '→', siteData.trustScore);\n        // Update data flow visualization\n        this.updateDataFlow(siteData, sourceDomain, trackerDomain);\n        this.siteData.set(sourceDomain, siteData);\n    }\n    isTrackerBlocked(domain) {\n        // Check if domain is in our blocking rules\n        const blockedDomains = ['doubleclick.net', 'googletagmanager.com', 'facebook.com/tr'];\n        return blockedDomains.some(blocked => domain.includes(blocked));\n    }\n    updateDataFlow(siteData, source, tracker) {\n        // Add nodes if they don't exist\n        if (!siteData.dataFlow.nodes.find(n => n.id === source)) {\n            siteData.dataFlow.nodes.push({\n                id: source,\n                domain: source,\n                type: 'source',\n                position: { x: 100, y: 100 }\n            });\n        }\n        if (!siteData.dataFlow.nodes.find(n => n.id === tracker)) {\n            const nodeCount = siteData.dataFlow.nodes.length;\n            siteData.dataFlow.nodes.push({\n                id: tracker,\n                domain: tracker,\n                type: 'tracker',\n                position: { x: 200 + (nodeCount * 100), y: 150 }\n            });\n        }\n        // Add edge if it doesn't exist\n        if (!siteData.dataFlow.edges.find(e => e.from === source && e.to === tracker)) {\n            siteData.dataFlow.edges.push({\n                from: source,\n                to: tracker,\n                dataType: 'user_data'\n            });\n        }\n    }\n    initializeSiteData(url) {\n        const domain = new URL(url).hostname;\n        console.log('🏠 Initializing site data for:', domain);\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url,\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n            console.log('✅ Site data initialized:', newSiteData);\n        }\n        else {\n            console.log('♻️ Site data already exists for:', domain);\n        }\n    }\n    initializeSiteDataForDomain(domain) {\n        console.log('🏠 Initializing site data for domain:', domain);\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url: `https://${domain}`, // Construct basic URL from domain\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n            console.log('✅ Site data initialized for domain:', newSiteData);\n        }\n        else {\n            console.log('♻️ Site data already exists for domain:', domain);\n        }\n    }\n    async getSiteData(url) {\n        const domain = new URL(url).hostname;\n        // Ensure site data exists for this domain\n        if (!this.siteData.has(domain)) {\n            console.log('🔄 Site data not found, initializing for:', domain);\n            this.initializeSiteData(url);\n        }\n        const siteData = this.siteData.get(domain) || null;\n        console.log('📊 Getting site data for:', domain, 'Found:', !!siteData, 'Trackers:', siteData?.trackers?.length || 0);\n        return siteData;\n    }\n    async toggleTrackerBlocking(enabled) {\n        // Toggle declarative net request rules\n        const ruleIds = [1, 2, 3, 4, 5]; // IDs from rules.json\n        if (enabled) {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                enableRulesetIds: ['tracker_rules']\n            });\n        }\n        else {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                disableRulesetIds: ['tracker_rules']\n            });\n        }\n    }\n    setupMessageListeners() {\n        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n            console.log('📨 Message received:', request.action, request);\n            switch (request.action) {\n                case 'getSiteData':\n                    this.getSiteData(request.url).then(sendResponse);\n                    return true;\n                case 'toggleBlocking':\n                    this.toggleTrackerBlocking(request.enabled).then(() => {\n                        sendResponse({ success: true });\n                    });\n                    return true;\n                case 'analyzePrivacyPolicy':\n                    this.analyzePrivacyPolicy(request.url).then(sendResponse);\n                    return true;\n                case 'privacyPoliciesFound':\n                    this.storePrivacyPolicyUrls(request.currentUrl, request.urls);\n                    sendResponse({ success: true });\n                    return true;\n                case 'debugInfo':\n                    // Return debug information\n                    const debugInfo = {\n                        trackedDomains: Array.from(this.siteData.keys()),\n                        totalSites: this.siteData.size,\n                        siteDataSnapshot: Array.from(this.siteData.entries()).map(([domain, data]) => ({\n                            domain,\n                            trackerCount: data.trackers.length,\n                            trustScore: data.trustScore\n                        }))\n                    };\n                    console.log('🐛 Debug info requested:', debugInfo);\n                    sendResponse(debugInfo);\n                    return true;\n            }\n        });\n    }\n    storePrivacyPolicyUrls(siteUrl, policyUrls) {\n        const domain = new URL(siteUrl).hostname;\n        this.privacyPolicyUrls.set(domain, policyUrls);\n    }\n    async analyzePrivacyPolicy(siteUrl) {\n        const domain = new URL(siteUrl).hostname;\n        const policyUrls = this.privacyPolicyUrls.get(domain) || [];\n        // If no privacy policy URLs found, try to find them\n        if (policyUrls.length === 0) {\n            // Try common privacy policy paths\n            const commonPaths = [\n                '/privacy',\n                '/privacy-policy',\n                '/privacy.html',\n                '/terms',\n                '/terms-of-service',\n                '/legal/privacy'\n            ];\n            for (const path of commonPaths) {\n                try {\n                    const response = await fetch(`https://${domain}${path}`);\n                    if (response.ok) {\n                        policyUrls.push(response.url);\n                        break;\n                    }\n                }\n                catch (e) {\n                    // Continue to next path\n                }\n            }\n        }\n        if (policyUrls.length === 0) {\n            return {\n                score: 50,\n                risks: ['No privacy policy found'],\n                summary: 'Unable to locate a privacy policy for this website.',\n                dataSharing: []\n            };\n        }\n        // Fetch and analyze the privacy policy\n        try {\n            const policyText = await this.fetchPrivacyPolicyText(policyUrls[0]);\n            const analysis = await this.performPrivacyAnalysis(policyText, domain);\n            // Store the analysis in site data\n            const siteData = this.siteData.get(domain);\n            if (siteData) {\n                siteData.privacyAnalysis = analysis;\n                this.siteData.set(domain, siteData);\n            }\n            return analysis;\n        }\n        catch (error) {\n            console.error('Privacy policy analysis failed:', error);\n            return {\n                score: 30,\n                risks: ['Failed to analyze privacy policy'],\n                summary: 'Privacy policy analysis failed due to technical issues.',\n                dataSharing: []\n            };\n        }\n    }\n    async fetchPrivacyPolicyText(policyUrl) {\n        const response = await fetch(policyUrl);\n        const html = await response.text();\n        // Extract text content from HTML (simple approach)\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html, 'text/html');\n        // Remove script and style elements\n        const scripts = doc.querySelectorAll('script, style');\n        scripts.forEach(el => el.remove());\n        return doc.body.textContent || doc.body.innerText || '';\n    }\n    async performPrivacyAnalysis(policyText, domain) {\n        // Mock AI-powered analysis (in real implementation, this would call an AI service)\n        const text = policyText.toLowerCase();\n        const risks = [];\n        const dataSharing = [];\n        let score = 70; // Base score\n        // Analyze for common privacy risks\n        if (text.includes('sell') && text.includes('personal information')) {\n            risks.push('May sell personal information to third parties');\n            score -= 20;\n        }\n        if (text.includes('track') && text.includes('across websites')) {\n            risks.push('Tracks users across multiple websites');\n            score -= 15;\n        }\n        if (text.includes('advertising') && text.includes('personalized')) {\n            risks.push('Uses data for targeted advertising');\n            score -= 10;\n        }\n        if (text.includes('location') && text.includes('collect')) {\n            risks.push('Collects location data');\n            score -= 10;\n        }\n        if (!text.includes('opt-out') && !text.includes('opt out')) {\n            risks.push('Limited opt-out options');\n            score -= 15;\n        }\n        if (!text.includes('delete') && !text.includes('removal')) {\n            risks.push('No clear data deletion process');\n            score -= 10;\n        }\n        // Check for data sharing mentions\n        const commonPartners = [\n            'google', 'facebook', 'amazon', 'microsoft', 'adobe', 'salesforce',\n            'analytics', 'advertising', 'partners', 'affiliates', 'subsidiaries'\n        ];\n        commonPartners.forEach(partner => {\n            if (text.includes(partner)) {\n                if (partner === 'google')\n                    dataSharing.push('Google');\n                else if (partner === 'facebook')\n                    dataSharing.push('Meta/Facebook');\n                else if (partner === 'amazon')\n                    dataSharing.push('Amazon');\n                else if (partner === 'microsoft')\n                    dataSharing.push('Microsoft');\n                else if (partner === 'adobe')\n                    dataSharing.push('Adobe');\n                else if (partner === 'analytics')\n                    dataSharing.push('Analytics Providers');\n                else if (partner === 'advertising')\n                    dataSharing.push('Advertising Networks');\n                else if (partner === 'partners')\n                    dataSharing.push('Business Partners');\n            }\n        });\n        // Generate summary based on analysis\n        let summary = `This privacy policy has been analyzed for key privacy practices. `;\n        if (score >= 80) {\n            summary += 'The policy shows good privacy practices with clear user rights and limited data sharing.';\n        }\n        else if (score >= 60) {\n            summary += 'The policy shows moderate privacy practices but has some concerning data collection or sharing practices.';\n        }\n        else if (score >= 40) {\n            summary += 'The policy shows concerning privacy practices with extensive data collection and sharing.';\n        }\n        else {\n            summary += 'The policy shows poor privacy practices with significant risks to user privacy.';\n        }\n        return {\n            score: Math.max(0, Math.min(100, score)),\n            risks: risks.slice(0, 5), // Limit to 5 most important risks\n            summary,\n            dataSharing: [...new Set(dataSharing)].slice(0, 6) // Remove duplicates and limit\n        };\n    }\n}\nconst backgroundService = new BackgroundService();\n"],"names":[],"sourceRoot":""}