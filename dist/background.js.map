{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://kavach-trial/./src/utils/privacy.ts","webpack://kavach-trial/webpack/bootstrap","webpack://kavach-trial/webpack/runtime/define property getters","webpack://kavach-trial/webpack/runtime/hasOwnProperty shorthand","webpack://kavach-trial/webpack/runtime/make namespace object","webpack://kavach-trial/./src/background/index.ts"],"sourcesContent":["export class TrustScoreCalculator {\n    static calculateScore(trackers, privacyRisks = []) {\n        let score = 100;\n        // Deduct points for trackers\n        const trackerPenalty = Math.min(trackers.length * 5, 40);\n        score -= trackerPenalty;\n        // Deduct points for high-risk trackers\n        const highRiskTrackers = trackers.filter(t => ['advertising', 'social', 'analytics'].includes(t.category));\n        score -= highRiskTrackers.length * 3;\n        // Deduct points for privacy policy risks\n        score -= Math.min(privacyRisks.length * 8, 30);\n        return Math.max(0, Math.min(100, score));\n    }\n}\nexport class PrivacyPolicyAnalyzer {\n    static async analyzePolicy(url) {\n        try {\n            const response = await fetch(`${this.API_BASE_URL}/privacy-policy/analyze`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ url }),\n                signal: AbortSignal.timeout(30000) // 30 second timeout\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({}));\n                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n            }\n            const result = await response.json();\n            if (!result.success) {\n                throw new Error(result.error || 'Analysis failed');\n            }\n            return result.data;\n        }\n        catch (error) {\n            // Return enhanced fallback data based on error type\n            const fallbackAnalysis = {\n                score: 50,\n                risks: ['Unable to analyze privacy policy - please review manually'],\n                summary: 'Privacy policy analysis failed. This could be due to network issues, missing privacy policy, or service unavailability.',\n                safety: 'RISKY',\n                dataSharing: [],\n                industryType: 'Unknown',\n                positiveFeatures: [],\n                analysisDepth: 'Failed',\n                lastAnalyzed: new Date().toISOString()\n            };\n            // Provide more specific feedback based on error type\n            if (error instanceof Error) {\n                if (error.message.includes('timeout') || error.message.includes('AbortError')) {\n                    fallbackAnalysis.summary = 'Privacy policy analysis timed out. The website may be slow to respond.';\n                }\n                else if (error.message.includes('404') || error.message.includes('not found')) {\n                    fallbackAnalysis.summary = 'No privacy policy was found on this website.';\n                    fallbackAnalysis.score = 30;\n                    fallbackAnalysis.risks = ['No privacy policy found', 'Data practices unclear', 'User rights undefined'];\n                }\n                else if (error.message.includes('network') || error.message.includes('fetch')) {\n                    fallbackAnalysis.summary = 'Unable to connect to privacy analysis service.';\n                }\n            }\n            return fallbackAnalysis;\n        }\n    }\n    /**\n     * Find privacy policy URL for a website\n     */\n    static async findPrivacyPolicyUrl(url) {\n        try {\n            const response = await fetch(`${this.API_BASE_URL}/privacy-policy/find?url=${encodeURIComponent(url)}`, {\n                method: 'GET',\n                signal: AbortSignal.timeout(10000) // 10 second timeout\n            });\n            if (!response.ok) {\n                return null;\n            }\n            const result = await response.json();\n            return result.success ? result.data.policyUrl : null;\n        }\n        catch (error) {\n            console.error('Failed to find privacy policy URL:', error);\n            return null;\n        }\n    }\n}\n// Production Render API endpoint\nPrivacyPolicyAnalyzer.API_BASE_URL = process.env.NODE_ENV === 'production'\n    ? 'https://kavach-hackolution.onrender.com/api'\n    : 'https://kavach-hackolution.onrender.com/api'; // Use production API for both dev and prod\nexport const commonTrackers = {\n    'doubleclick.net': { category: 'advertising', name: 'Google DoubleClick' },\n    'googletagmanager.com': { category: 'analytics', name: 'Google Tag Manager' },\n    'facebook.com': { category: 'social', name: 'Facebook Pixel' },\n    'google-analytics.com': { category: 'analytics', name: 'Google Analytics' },\n    'connect.facebook.net': { category: 'social', name: 'Facebook Connect' },\n    'amazon-adsystem.com': { category: 'advertising', name: 'Amazon Advertising' },\n    'twitter.com': { category: 'social', name: 'Twitter Analytics' },\n    'linkedin.com': { category: 'social', name: 'LinkedIn Insights' }\n};\nexport class OptOutManager {\n    static getOptOutStrategy(domain) {\n        // Find matching strategy for domain or subdomain\n        const strategies = Object.keys(this.OPT_OUT_STRATEGIES);\n        const matchingStrategy = strategies.find(strategyDomain => domain.includes(strategyDomain) || strategyDomain.includes(domain));\n        return matchingStrategy ? this.OPT_OUT_STRATEGIES[matchingStrategy] : null;\n    }\n    static getUniversalOptOutCookies() {\n        return [\n            'gdpr_consent=false',\n            'ccpa_optout=true',\n            'privacy_optout=true',\n            'cookie_consent=rejected',\n            'tracking_consent=false',\n            'analytics_consent=false',\n            'marketing_consent=false',\n            'personalization_consent=false',\n            'advertising_consent=false',\n            'functional_consent=false',\n            'performance_consent=false',\n            'social_media_consent=false',\n            'opt_out=true',\n            'privacy_settings=all_rejected',\n            'consent_mode=opt_out',\n            'do_not_track=1',\n            'user_consent_status=rejected',\n            // OneTrust specific\n            'OptanonConsent=',\n            'OptanonAlertBoxClosed=',\n            // Cookiebot specific\n            'CookieConsent=no',\n            // TrustArc specific\n            'notice_behavior=implied,eu',\n            'notice_gdpr_prefs=0,1,2,3:',\n            // Quantcast specific\n            'euconsent-v2=',\n            // Generic IAB consent\n            'gdpr=1',\n            'gdpr_consent=',\n            // Site-specific patterns\n            'cookies_accepted=false',\n            'accept_cookies=no',\n            'cookie_policy_accepted=false',\n            'data_processing_consent=false'\n        ];\n    }\n    static getUniversalOptOutSelectors() {\n        return [\n            // Generic opt-out buttons\n            'button[data-testid*=\"reject\"]',\n            'button[data-testid*=\"decline\"]',\n            'button[data-testid*=\"opt-out\"]',\n            'button[class*=\"reject\"]',\n            'button[class*=\"decline\"]',\n            'button[class*=\"opt-out\"]',\n            'a[href*=\"opt-out\"]',\n            'a[href*=\"unsubscribe\"]',\n            'a[href*=\"privacy-settings\"]',\n            // OneTrust CMP\n            '#onetrust-reject-all-handler',\n            '#onetrust-pc-btn-handler',\n            '.optanon-category-2',\n            '.optanon-category-3',\n            '.optanon-category-4',\n            // Cookiebot CMP\n            '#CybotCookiebotDialogBodyButtonDecline',\n            '#CybotCookiebotDialogBodyLevelButtonLevelOptinDeclineAll',\n            // TrustArc CMP\n            '#truste-consent-required',\n            '.truste-button-2',\n            // Quantcast CMP\n            '.qc-cmp2-summary-buttons > button:last-child',\n            '.qc-cmp2-toggle-switch',\n            // Generic consent management\n            '[data-cy*=\"reject\"]',\n            '[data-cy*=\"decline\"]',\n            '[data-cy=\"manage-consent-reject-all\"]',\n            '[data-testid=\"consent-reject-all\"]',\n            '.sp_choice_type_REJECT_ALL',\n            // Common cookie banner patterns\n            '.cookie-banner button[data-role=\"reject\"]',\n            '.gdpr-banner .reject-all',\n            '.consent-manager .decline-all',\n            '.privacy-banner .opt-out',\n            // Language-specific patterns\n            'button:contains(\"Reject All\")',\n            'button:contains(\"Decline All\")',\n            'button:contains(\"Opt Out\")',\n            'button:contains(\"Refuse All\")',\n            'button:contains(\"Deny All\")',\n            'button:contains(\"No Thanks\")',\n            'button:contains(\"Disagree\")',\n            // Logout buttons\n            'a[href*=\"logout\"]',\n            'a[href*=\"signout\"]',\n            'a[href*=\"sign-out\"]',\n            'button[data-testid*=\"logout\"]',\n            'button[data-testid*=\"signout\"]',\n            '.logout', '.signout', '.sign-out'\n        ];\n    }\n    static getTrackingDomainsToBlock() {\n        return [\n            // Google tracking\n            'google-analytics.com',\n            'googletagmanager.com',\n            'doubleclick.net',\n            'googlesyndication.com',\n            'googleadservices.com',\n            'gstatic.com',\n            // Facebook/Meta tracking  \n            'facebook.com',\n            'facebook.net',\n            'connect.facebook.net',\n            // Amazon tracking\n            'amazon-adsystem.com',\n            'amazonpay.com',\n            // Microsoft tracking\n            'bing.com',\n            'microsoft.com',\n            'live.com',\n            // Social media tracking\n            'twitter.com',\n            'linkedin.com',\n            'pinterest.com',\n            'tiktok.com',\n            'snapchat.com',\n            // Analytics platforms\n            'mixpanel.com',\n            'segment.com',\n            'amplitude.com',\n            'hotjar.com',\n            'fullstory.com',\n            'logrocket.com',\n            'mouseflow.com',\n            'crazyegg.com',\n            'optimizely.com',\n            // Ad networks\n            'criteo.com',\n            'outbrain.com',\n            'taboola.com',\n            'pubmatic.com',\n            'rubiconproject.com',\n            'openx.com',\n            'adsystem.com'\n        ];\n    }\n}\n// Website-specific opt-out mechanisms\nOptOutManager.OPT_OUT_STRATEGIES = {\n    'google.com': {\n        cookiesToSet: [\n            'CONSENT=PENDING+999',\n            'NID=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'ANID=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"reject-all\"]', '.QS5gu'],\n        logoutUrl: 'https://accounts.google.com/logout'\n    },\n    'facebook.com': {\n        cookiesToSet: [\n            'dpr=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'wd=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"cookie-policy-manage-dialog-decline-button\"]'],\n        logoutUrl: 'https://www.facebook.com/logout.php'\n    },\n    'amazon.com': {\n        cookiesToSet: [\n            'ad-privacy=0',\n            'csm-hit=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-cy=\"sp_choice_type_REJECT_ALL\"]'],\n        logoutUrl: 'https://www.amazon.com/gp/flex/sign-out.html'\n    },\n    'twitter.com': {\n        cookiesToSet: [\n            'personalization_id=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'guest_id=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"decline\"]'],\n        logoutUrl: 'https://twitter.com/logout'\n    },\n    'linkedin.com': {\n        cookiesToSet: [\n            'UserMatchHistory=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'AnalyticsSyncHistory=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-tracking-control-name=\"consent-banner_decline-all\"]'],\n        logoutUrl: 'https://www.linkedin.com/uas/logout'\n    },\n    'youtube.com': {\n        cookiesToSet: [\n            'CONSENT=PENDING+999',\n            'VISITOR_INFO1_LIVE=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[aria-label=\"Reject all\"]', '[data-testid=\"reject-all-button\"]'],\n        logoutUrl: 'https://accounts.google.com/logout'\n    },\n    'instagram.com': {\n        cookiesToSet: [\n            'ig_nrcb=; expires=Thu, 01 Jan 1970 00:00:00 GMT',\n            'csrftoken=; expires=Thu, 01 Jan 1970 00:00:00 GMT'\n        ],\n        selectors: ['[data-testid=\"cookie-banner-decline\"]'],\n        logoutUrl: 'https://www.instagram.com/accounts/logout/'\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { TrustScoreCalculator, PrivacyPolicyAnalyzer, commonTrackers } from '../utils/privacy';\n// LRU Cache for SiteData with persistence\nclass LRUCache {\n    constructor(maxEntries) {\n        this.maxEntries = maxEntries;\n        this.map = new Map();\n    }\n    get(key) {\n        if (!this.map.has(key))\n            return undefined;\n        const value = this.map.get(key);\n        // Move to end (most recently used)\n        this.map.delete(key);\n        this.map.set(key, value);\n        console.log(`[LRUCache] HIT for key:`, key);\n        return value;\n    }\n    set(key, value) {\n        if (this.map.has(key)) {\n            this.map.delete(key);\n            console.log(`[LRUCache] UPDATE for key:`, key);\n        }\n        else if (this.map.size >= this.maxEntries) {\n            // Remove least recently used\n            const iterator = this.map.keys();\n            const lruKey = iterator.next().value;\n            if (lruKey !== undefined) {\n                this.map.delete(lruKey);\n                console.log(`[LRUCache] EVICTED least recently used key:`, lruKey);\n            }\n            console.log(`[LRUCache] SET (new, after eviction if needed) for key:`, key);\n        }\n        else {\n            console.log(`[LRUCache] SET (new) for key:`, key);\n        }\n        this.map.set(key, value);\n    }\n    delete(key) {\n        this.map.delete(key);\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    keys() {\n        return Array.from(this.map.keys());\n    }\n    values() {\n        return Array.from(this.map.values());\n    }\n    entries() {\n        return Array.from(this.map.entries());\n    }\n    toJSON() {\n        return Array.from(this.map.entries());\n    }\n    fromJSON(entries) {\n        this.map = new Map(entries);\n    }\n}\nclass BackgroundService {\n    constructor() {\n        this.siteData = new Map();\n        this.blockedRequests = new Map();\n        this.privacyPolicyUrls = new Map();\n        this.MAX_SITE_DATA_ENTRIES = 100; // Prevent memory bloat\n        this.MAX_TRACKERS_PER_SITE = 50; // Limit trackers per site\n        this.lruCache = new LRUCache(100); // 100 entries max\n        this.setupRequestBlocking();\n        this.setupTabListeners();\n        this.setupMessageListeners();\n        this.loadCacheFromStorage();\n        setInterval(() => this.cleanupOldData(), 300000); // Every 5 minutes\n        setInterval(() => this.saveCacheToStorage(), 60000); // Save cache every 1 min\n    }\n    safeParseURL(url) {\n        try {\n            if (!url || typeof url !== 'string')\n                return null;\n            return new URL(url);\n        }\n        catch {\n            return null;\n        }\n    }\n    getDomainFromURL(url) {\n        const parsedUrl = this.safeParseURL(url);\n        return parsedUrl ? parsedUrl.hostname : null;\n    }\n    setupRequestBlocking() {\n        // Monitor web requests to track third-party requests\n        chrome.webRequest.onBeforeRequest.addListener((details) => {\n            if (details.type === 'main_frame')\n                return {};\n            const url = this.safeParseURL(details.url);\n            const initiatorUrl = details.initiator ? this.safeParseURL(details.initiator) : null;\n            if (url && initiatorUrl && url.hostname !== initiatorUrl.hostname) {\n                this.trackThirdPartyRequest(initiatorUrl.hostname, url.hostname, details.type);\n            }\n            return {};\n        }, { urls: ['<all_urls>'] }, ['requestBody']);\n    }\n    setupTabListeners() {\n        chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n            if (changeInfo.status === 'complete' && tab.url && this.isValidHttpUrl(tab.url)) {\n                this.initializeSiteData(tab.url);\n            }\n        });\n        chrome.tabs.onActivated.addListener(async (activeInfo) => {\n            try {\n                const tab = await chrome.tabs.get(activeInfo.tabId);\n                if (tab.url && this.isValidHttpUrl(tab.url)) {\n                    this.initializeSiteData(tab.url);\n                }\n            }\n            catch (error) {\n                // Silently handle tab access errors\n            }\n        });\n    }\n    isValidHttpUrl(url) {\n        try {\n            const parsedUrl = new URL(url);\n            return parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:';\n        }\n        catch {\n            return false;\n        }\n    }\n    trackThirdPartyRequest(sourceDomain, trackerDomain, requestType) {\n        try {\n            let siteData = this.siteData.get(sourceDomain);\n            if (!siteData) {\n                this.initializeSiteDataForDomain(sourceDomain);\n                siteData = this.siteData.get(sourceDomain);\n                if (!siteData)\n                    return;\n            }\n            // Prevent tracking invalid domains\n            if (!trackerDomain || trackerDomain === sourceDomain)\n                return;\n            const existingTracker = siteData.trackers.find(t => t.domain === trackerDomain);\n            if (existingTracker) {\n                existingTracker.count = Math.min(existingTracker.count + 1, 1000); // Cap at 1000\n            }\n            else {\n                // Prevent adding too many trackers\n                if (siteData.trackers.length >= this.MAX_TRACKERS_PER_SITE)\n                    return;\n                const trackerInfo = commonTrackers[trackerDomain];\n                const newTracker = {\n                    domain: trackerDomain,\n                    count: 1,\n                    category: trackerInfo?.category || 'unknown',\n                    blocked: this.isTrackerBlocked(trackerDomain)\n                };\n                siteData.trackers.push(newTracker);\n            }\n            // Recalculate trust score\n            siteData.trustScore = TrustScoreCalculator.calculateScore(siteData.trackers);\n            // Update data flow visualization\n            this.updateDataFlow(siteData, sourceDomain, trackerDomain);\n            this.siteData.set(sourceDomain, siteData);\n        }\n        catch (error) {\n            // Silently handle tracking errors to prevent extension crashes\n        }\n    }\n    isTrackerBlocked(domain) {\n        // Check if domain is in our blocking rules\n        const blockedDomains = ['doubleclick.net', 'googletagmanager.com', 'facebook.com/tr'];\n        return blockedDomains.some(blocked => domain.includes(blocked));\n    }\n    updateDataFlow(siteData, source, tracker) {\n        // Add nodes if they don't exist\n        if (!siteData.dataFlow.nodes.find(n => n.id === source)) {\n            siteData.dataFlow.nodes.push({\n                id: source,\n                domain: source,\n                type: 'source',\n                position: { x: 100, y: 100 }\n            });\n        }\n        if (!siteData.dataFlow.nodes.find(n => n.id === tracker)) {\n            const nodeCount = siteData.dataFlow.nodes.length;\n            siteData.dataFlow.nodes.push({\n                id: tracker,\n                domain: tracker,\n                type: 'tracker',\n                position: { x: 200 + (nodeCount * 100), y: 150 }\n            });\n        }\n        // Add edge if it doesn't exist\n        if (!siteData.dataFlow.edges.find(e => e.from === source && e.to === tracker)) {\n            siteData.dataFlow.edges.push({\n                from: source,\n                to: tracker,\n                dataType: 'user_data'\n            });\n        }\n    }\n    initializeSiteData(url) {\n        const domain = this.getDomainFromURL(url);\n        if (!domain)\n            return;\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url,\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n        }\n    }\n    initializeSiteDataForDomain(domain) {\n        if (!this.siteData.has(domain)) {\n            const newSiteData = {\n                url: `https://${domain}`,\n                trustScore: 100,\n                trackers: [],\n                dataFlow: {\n                    nodes: [],\n                    edges: []\n                }\n            };\n            this.siteData.set(domain, newSiteData);\n        }\n    }\n    async getSiteData(url) {\n        const domain = this.getDomainFromURL(url);\n        if (!domain)\n            return null;\n        // Check LRU cache first (freshness: 24h)\n        const cached = this.lruCache.get(domain);\n        const now = Date.now();\n        if (cached && (now - cached.timestamp < 24 * 60 * 60 * 1000)) {\n            return cached.data;\n        }\n        // Not cached or stale, fetch/analyze as usual\n        if (!this.siteData.has(domain)) {\n            this.initializeSiteData(url);\n        }\n        const data = this.siteData.get(domain) || null;\n        if (data) {\n            this.lruCache.set(domain, { data, timestamp: now });\n            this.saveCacheToStorage();\n        }\n        return data;\n    }\n    async toggleTrackerBlocking(enabled) {\n        // Toggle declarative net request rules\n        const ruleIds = [1, 2, 3, 4, 5]; // IDs from rules.json\n        if (enabled) {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                enableRulesetIds: ['tracker_rules']\n            });\n        }\n        else {\n            await chrome.declarativeNetRequest.updateEnabledRulesets({\n                disableRulesetIds: ['tracker_rules']\n            });\n        }\n    }\n    setupMessageListeners() {\n        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n            switch (request.action) {\n                case 'getSiteData':\n                    this.getSiteData(request.url).then(sendResponse);\n                    return true;\n                case 'toggleBlocking':\n                    this.toggleTrackerBlocking(request.enabled).then(() => {\n                        sendResponse({ success: true });\n                    }).catch(() => {\n                        sendResponse({ success: false });\n                    });\n                    return true;\n                case 'analyzePrivacyPolicy':\n                    this.analyzePrivacyPolicy(request.url).then(sendResponse);\n                    return true;\n                case 'privacyPoliciesFound':\n                    this.storePrivacyPolicyUrls(request.currentUrl, request.urls);\n                    sendResponse({ success: true });\n                    return true;\n                case 'debugInfo':\n                    const debugInfo = {\n                        trackedDomains: Array.from(this.siteData.keys()),\n                        totalSites: this.siteData.size,\n                        siteDataSnapshot: Array.from(this.siteData.entries()).map(([domain, data]) => ({\n                            domain,\n                            trackerCount: data.trackers.length,\n                            trustScore: data.trustScore\n                        }))\n                    };\n                    sendResponse(debugInfo);\n                    return true;\n                case 'runFingerprint':\n                    if (request.tabId) {\n                        this.handleFingerprinting(request.tabId)\n                            .then(sendResponse)\n                            .catch(error => sendResponse({ success: false, error: error.message }));\n                    }\n                    else {\n                        sendResponse({ success: false, error: 'No tabId provided in the request.' });\n                    }\n                    return true;\n                case 'performOptOut':\n                    this.performComprehensiveOptOut(request.url, request.tabId)\n                        .then(sendResponse)\n                        .catch((error) => sendResponse({ success: false, error: error.message }));\n                    return true;\n                case 'clearKavachCache':\n                    this.lruCache = new LRUCache(100);\n                    this.siteData.clear();\n                    chrome.storage.local.remove('kavachSiteDataCache', () => {\n                        sendResponse({ success: true });\n                    });\n                    return true;\n                default:\n                    sendResponse({ error: 'Unknown action' });\n                    return false;\n            }\n        });\n    }\n    storePrivacyPolicyUrls(siteUrl, policyUrls) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (domain && Array.isArray(policyUrls)) {\n            this.privacyPolicyUrls.set(domain, policyUrls);\n        }\n    }\n    async analyzePrivacyPolicy(siteUrl) {\n        const domain = this.getDomainFromURL(siteUrl);\n        if (!domain) {\n            return { error: 'Invalid URL provided' };\n        }\n        // Check LRU cache for privacyAnalysis freshness (24h)\n        const cached = this.lruCache.get(domain);\n        const now = Date.now();\n        if (cached && cached.data.privacyAnalysis && (now - (new Date(cached.data.privacyAnalysis.lastAnalyzed || 0).getTime()) < 24 * 60 * 60 * 1000)) {\n            return cached.data.privacyAnalysis;\n        }\n        // Not cached or stale, call API\n        try {\n            const analysis = await PrivacyPolicyAnalyzer.analyzePolicy(siteUrl);\n            // Store the analysis in site data\n            const siteData = this.siteData.get(domain) || {\n                url: siteUrl,\n                trustScore: 100,\n                trackers: [],\n                dataFlow: { nodes: [], edges: [] }\n            };\n            if (analysis) {\n                const processedAnalysis = {\n                    score: Math.max(0, Math.min(100, analysis.score || 50)),\n                    risks: Array.isArray(analysis.risks) ? analysis.risks.slice(0, 10) : [],\n                    summary: analysis.summary || 'Privacy policy analysis completed.',\n                    safety: ['SAFE', 'RISKY', 'UNSAFE'].includes(analysis.safety) ? analysis.safety : 'RISKY',\n                    dataSharing: Array.isArray(analysis.dataSharing) ? analysis.dataSharing.slice(0, 8) : [],\n                    industryType: analysis.industryType || 'Unknown',\n                    positiveFeatures: Array.isArray(analysis.positiveFeatures) ? analysis.positiveFeatures.slice(0, 5) : [],\n                    analysisDepth: analysis.analysisDepth || 'AI Analysis',\n                    lastAnalyzed: new Date().toISOString()\n                };\n                siteData.privacyAnalysis = processedAnalysis;\n                this.siteData.set(domain, siteData);\n                this.lruCache.set(domain, { data: siteData, timestamp: now });\n                this.saveCacheToStorage();\n                return processedAnalysis;\n            }\n            return analysis;\n        }\n        catch (error) {\n            // Fallback\n            const fallbackAnalysis = {\n                score: 50,\n                risks: ['Unable to analyze privacy policy - service temporarily unavailable'],\n                summary: 'Privacy policy analysis failed. Please try again later or review the policy manually.',\n                safety: 'RISKY',\n                dataSharing: [],\n                industryType: 'Unknown',\n                positiveFeatures: [],\n                analysisDepth: 'Failed',\n                lastAnalyzed: new Date().toISOString()\n            };\n            const siteData = this.siteData.get(domain);\n            if (siteData) {\n                siteData.privacyAnalysis = fallbackAnalysis;\n                this.siteData.set(domain, siteData);\n                this.lruCache.set(domain, { data: siteData, timestamp: now });\n                this.saveCacheToStorage();\n            }\n            return fallbackAnalysis;\n        }\n    }\n    async handleFingerprinting(tabId) {\n        try {\n            // First, check if we can access the tab\n            const tab = await chrome.tabs.get(tabId);\n            if (!tab.url || tab.url.startsWith('chrome://') || tab.url.startsWith('moz-extension://')) {\n                throw new Error('Fingerprinting not available on browser internal pages');\n            }\n            // Inject the bundled fingerprinting script into the active tab's main world\n            await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                files: ['fingerprint-agent.js'],\n                world: 'MAIN'\n            });\n            // Now execute the code to run FingerprintJS in the main world\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                func: runFingerprintJSOpenSource,\n                args: [],\n                world: 'MAIN'\n            });\n            if (results && results[0] && results[0].result) {\n                return results[0].result;\n            }\n            else {\n                throw new Error('No result returned from fingerprinting script');\n            }\n        }\n        catch (error) {\n            console.error('Background fingerprinting error:', error);\n            // Provide more user-friendly error messages\n            let errorMessage = error.message;\n            if (errorMessage.includes('Cannot access') || errorMessage.includes('chrome://')) {\n                errorMessage = 'Fingerprinting not available on this page type';\n            }\n            else if (errorMessage.includes('CSP') || errorMessage.includes('Content Security Policy')) {\n                errorMessage = 'Website security policy blocks fingerprinting';\n            }\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    }\n    async performComprehensiveOptOut(url, tabId) {\n        try {\n            const domain = this.getDomainFromURL(url);\n            if (!domain) {\n                throw new Error('Invalid URL provided');\n            }\n            // Step 1: Update tracking rules to block this domain\n            await this.addDomainToBlockList(domain);\n            // Step 2: Clear all request tracking for this domain\n            this.clearDomainTrackingData(domain);\n            // Step 3: Block all future third-party requests from this domain\n            await this.enableEnhancedBlockingForDomain(domain);\n            // Step 4: Clear any stored privacy policy data\n            this.privacyPolicyUrls.delete(domain);\n            // Step 5: Mark domain as opted out\n            await chrome.storage.local.set({\n                [`optedOut_${domain}`]: {\n                    timestamp: Date.now(),\n                    userInitiated: true,\n                    comprehensive: true\n                }\n            });\n            // Step 6: Reset trust score to reflect opt-out status\n            const siteData = this.siteData.get(domain);\n            if (siteData) {\n                siteData.trustScore = 95; // High score due to opt-out\n                siteData.trackers = []; // Clear tracked requests\n                this.siteData.set(domain, siteData);\n            }\n            return {\n                success: true,\n                message: `Comprehensive opt-out completed for ${domain}`\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Opt-out failed: ${error.message}`\n            };\n        }\n    }\n    async addDomainToBlockList(domain) {\n        try {\n            const storage = await chrome.storage.local.get(['blockedDomains']);\n            const blockedDomains = storage.blockedDomains || [];\n            if (!blockedDomains.includes(domain)) {\n                blockedDomains.push(domain);\n                await chrome.storage.local.set({ blockedDomains });\n            }\n        }\n        catch (error) {\n            // Silently handle storage errors\n        }\n    }\n    clearDomainTrackingData(domain) {\n        try {\n            // Remove from site data\n            this.siteData.delete(domain);\n            // Clear blocked requests count\n            const keysToDelete = Array.from(this.blockedRequests.keys())\n                .filter(key => key.includes(domain));\n            keysToDelete.forEach(key => this.blockedRequests.delete(key));\n        }\n        catch (error) {\n            // Silently handle cleanup errors\n        }\n    }\n    async enableEnhancedBlockingForDomain(domain) {\n        try {\n            // Create dynamic rules to block requests from this domain\n            const newRules = [\n                {\n                    id: Date.now(),\n                    priority: 1,\n                    action: { type: 'block' },\n                    condition: {\n                        initiatorDomains: [domain],\n                        resourceTypes: [\n                            'script',\n                            'xmlhttprequest',\n                            'image',\n                            'media',\n                            'font',\n                            'websocket'\n                        ]\n                    }\n                }\n            ];\n            // Enhanced blocking for specific domains\n            if (domain.includes('youtube.com') || domain.includes('google.com')) {\n                const baseId = Date.now();\n                newRules.push({\n                    id: baseId + 1,\n                    priority: 2,\n                    action: { type: 'block' },\n                    condition: {\n                        urlFilter: '*youtube.com/api/stats*',\n                        resourceTypes: ['xmlhttprequest']\n                    }\n                }, {\n                    id: baseId + 2,\n                    priority: 2,\n                    action: { type: 'block' },\n                    condition: {\n                        urlFilter: '*youtube.com/youtubei/v1/log_event*',\n                        resourceTypes: ['xmlhttprequest']\n                    }\n                }, {\n                    id: baseId + 3,\n                    priority: 2,\n                    action: { type: 'block' },\n                    condition: {\n                        urlFilter: '*youtube.com/ptracking*',\n                        resourceTypes: ['xmlhttprequest', 'image']\n                    }\n                });\n            }\n            await chrome.declarativeNetRequest.updateDynamicRules({\n                addRules: newRules\n            });\n        }\n        catch (error) {\n            // Silently handle rule creation errors\n        }\n    }\n    cleanupOldData() {\n        // Limit the number of stored site data entries\n        if (this.siteData.size > this.MAX_SITE_DATA_ENTRIES) {\n            const entries = Array.from(this.siteData.entries());\n            const sortedEntries = entries.sort((a, b) => {\n                const aTime = a[1].privacyAnalysis?.lastAnalyzed || '0';\n                const bTime = b[1].privacyAnalysis?.lastAnalyzed || '0';\n                return aTime.localeCompare(bTime);\n            });\n            // Remove oldest entries\n            const toRemove = sortedEntries.slice(0, this.siteData.size - this.MAX_SITE_DATA_ENTRIES);\n            toRemove.forEach(([domain]) => {\n                this.siteData.delete(domain);\n            });\n        }\n        // Limit trackers per site to prevent memory bloat\n        this.siteData.forEach((siteData, domain) => {\n            if (siteData.trackers.length > this.MAX_TRACKERS_PER_SITE) {\n                // Keep only the most frequent trackers\n                siteData.trackers = siteData.trackers\n                    .sort((a, b) => b.count - a.count)\n                    .slice(0, this.MAX_TRACKERS_PER_SITE);\n                // Recalculate trust score after cleanup\n                siteData.trustScore = TrustScoreCalculator.calculateScore(siteData.trackers);\n            }\n        });\n    }\n    // Load LRU cache from chrome.storage.local\n    async loadCacheFromStorage() {\n        try {\n            const result = await chrome.storage.local.get(['kavachSiteDataCache']);\n            if (result.kavachSiteDataCache) {\n                this.lruCache.fromJSON(result.kavachSiteDataCache);\n            }\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n    // Save LRU cache to chrome.storage.local\n    async saveCacheToStorage() {\n        try {\n            await chrome.storage.local.set({\n                kavachSiteDataCache: this.lruCache.toJSON()\n            });\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n}\n// This function gets injected into the webpage to run the open source FingerprintJS\nfunction runFingerprintJSOpenSource() {\n    return new Promise((resolve) => {\n        // The FingerprintJS object is now available on the window\n        // thanks to the injected fingerprint-agent.js script.\n        async function initializeFingerprint() {\n            try {\n                const fp = await window.FingerprintJS.load();\n                const result = await fp.get();\n                // Simulate some additional data that was available in Pro for backward compatibility\n                const mockBotDetection = {\n                    probability: Math.random() > 0.8 ? 0.8 : 0.1, // Random bot probability for demo\n                    type: Math.random() > 0.8 ? 'likely' : 'unlikely'\n                };\n                resolve({\n                    success: true,\n                    data: {\n                        visitorId: result.visitorId,\n                        confidence: { score: 0.95 }, // Open source doesn't provide confidence, so we mock it\n                        bot: mockBotDetection,\n                        components: result.components,\n                        timestamp: Date.now(),\n                        lastSeen: Date.now() - Math.floor(Math.random() * 86400000) // Random last seen within 24h\n                    }\n                });\n            }\n            catch (error) {\n                resolve({\n                    success: false,\n                    error: `Fingerprinting failed: ${error.message}`\n                });\n            }\n        }\n        // Wait for the FingerprintJS object to be available\n        let checks = 0;\n        const interval = setInterval(() => {\n            checks++;\n            if (window.FingerprintJS) {\n                clearInterval(interval);\n                initializeFingerprint();\n            }\n            else if (checks > 50) { // Timeout after 5 seconds\n                clearInterval(interval);\n                resolve({ success: false, error: 'FingerprintJS object not found after script injection.' });\n            }\n        }, 100);\n    });\n}\n// Keep the old Pro function for reference but mark it as deprecated\nfunction runFingerprintJS(apiKey) {\n    return new Promise((resolve) => {\n        resolve({\n            success: false,\n            error: 'Pro version has been deprecated. Using open source version instead.'\n        });\n    });\n}\nconst backgroundService = new BackgroundService();\n"],"names":[],"sourceRoot":""}